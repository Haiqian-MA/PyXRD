# coding=UTF-8
# ex:ts=4:sw=4:et=on

# Copyright (c) 2013, Mathijs Dumon
# All rights reserved.
# Complete license can be found in the LICENSE file.

from traceback import format_exc
import locale, itertools, sys

import gtk

import numpy as np
import scipy
import scipy.spatial.qhull as qhull

import matplotlib
from mpl_toolkits.axes_grid1 import ImageGrid
import mpl_toolkits.axes_grid1.axes_size as Size
from mpl_toolkits.axes_grid1 import Divider
from generic.mathtext_support import get_plot_safe

from gtkmvc import Controller, Observer
from gtkmvc.adapters import Adapter

from generic.sorted_collection import SortedCollection
from generic.views.treeview_tools import new_text_column, new_pb_column, new_toggle_column
from generic.mathtext_support import create_pb_from_mathtext
from generic.controllers import DialogController, BaseController, ObjectListStoreController
from generic.controllers.utils import ctrl_setup_combo_with_list
from generic.views.validators import FloatEntryValidator #FIXME use handlers!

from phases.models import Phase, Component

from mixture.models import Mixture
from mixture.views import EditMixtureView, RefinementView, RefinementResultView

class RefinementResultsController(DialogController):
    """
        A controller for a RefinementContext object that keeps track
        of the solutions and residuals generated by the refinement
        algorithm. This allows to show a nice dialog with the end
        results and some graphs about the parameter space.
    """
    
    solutions = None
    
    # ------------------------------------------------------------
    #      Initialisation and other internals
    # ------------------------------------------------------------        
    def register_adapters(self):
        if self.model is not None:
            for name in ("initial_residual", "last_residual", "best_residual"):
                self.adapt(name, "lbl_%s" % name)
        
    # ------------------------------------------------------------
    #      Notifications of observable properties
    # ------------------------------------------------------------   
    @Controller.observe("solution_added", signal=True)
    def notif_solution_added(self, model, prop_name, info):
        new_solution, new_residual = info.arg
        self.record(new_solution, new_residual)
                
    # ------------------------------------------------------------
    #      GTK Signal handlers
    # ------------------------------------------------------------
    def on_btn_initial_clicked(self, event):
        self.model.apply_initial_solution()
        self.model.mixture.refiner.delete_context()
        self.on_cancel()
        return True
        
    def on_btn_best_clicked(self, event):
        self.model.apply_best_solution()
        self.model.mixture.refiner.delete_context()
        self.on_cancel()
        return True
        
    def on_btn_last_clicked(self, event):
        self.model.apply_last_solution()
        self.model.mixture.refiner.delete_context()
        self.on_cancel()
        return True
        
    # ------------------------------------------------------------
    #      Methods & Functions
    # ------------------------------------------------------------
    def record(self, solution, residual):
        """
            Add a new solution to the list of solutions
        """
        try: 
            new_record = list(solution)
        except TypeError: #not an iterable
            new_record = [solution,]
        if self.solutions==None:
            self.solutions = SortedCollection(key=lambda s: s[0], max_items=2000)
        self.solutions.insert((residual, new_record))
        
    def get_extents(self, centroid, mins, maxs, density=10):
        """
            Calculates extents for the given minimum and maximum values so
            the centroid coordinates falls on the grid. This ensures the
            minimum point can be acurately represented on the plot.
            
            This is achieved by slightly shifting the grid, or with other words,
            the minimum and maximum values
        """
        slices = []
        rmins = []
        rmaxs = []
        centroid_indexes = []
        for c, mn, mx in zip(centroid, mins, maxs):
            #Correct small offsets from the centroid.
            #This assumes the centroid to be in the min and max ranges
            normal = np.linspace(mn, mx, density)
            idx = (np.abs(normal-c)).argmin()
            centroid_indexes.append(idx)
            closest = normal[idx]
            diff = c - closest
            rmin = mn+diff
            rmax = mx+diff
            rmins.append(rmin)
            rmaxs.append(rmax)
            slices.append(slice(rmin,rmax,complex(density)))
            
        return np.array(centroid_indexes), np.array(rmins), np.array(rmaxs)
        
    def parse_solutions(self, centroid, density=10):
        """
            Returns a tuple containing:
                - point array (Nsolutions, Nparams) : contains 'coordinates'
                - value array (Nsolutions) : contains residuals
                - centroid indeces in the final grid
                - grid minimum and maximum values shifted as explained in get_extents
        """
        points = np.array([point for value, point in self.solutions])
        values = np.array([value for value, point in self.solutions])
                
        mins = points.min(axis=0)
        maxs = points.max(axis=0)
                
        return (points, values) + self.get_extents(
            centroid=np.array(centroid),
            mins=mins,
            maxs=maxs,
            density=density
        )
     
    def generate_images(self, output_dir="", density=200):
        """
            Generate the parameter space plots
        """
        try:
            #Central point:
            centroid = self.model.best_solution
            try: 
                centroid = list(centroid)
            except TypeError: #not an iterable:
                centroid = [centroid,]

            #Some information:            
            points, values, centroid_indexes, mins, maxs = \
                self.parse_solutions(centroid, density=density)
                
            #How many parameters?
            dims = points.shape[1]

            figure, canvas = self.view.figure, self.view.canvas

            if dims == 1: #Only one parameter refined
                points = points.flatten()
                values = values.flatten()
                ax = figure.add_subplot(1,1,1)
                ax.plot(points, values)
                ax.set_ylabel("Residual error")
                ax.set_xlabel(self.model.ref_props[0].title)
            else: #Multi-parameter space:
                """
                    An example of how grid, parameter and view numbers change
                    for dims = 4
                    
                    The numbers in the grid are:
                    
                    parameter x, parameter y
                    grid x, grid y
                
                    -----------------------------------------------------
                    |            |            |            |            |
                    |    0, 0    |    1, 0    |    2, 0    |    3, 0    |
                    |    -, -    |    -, -    |    -, -    |    -, -    |
                    |            |            |            |            |
                    ==============------------|------------|------------|
                    I            I            |            |            |
                    I    0, 1    I    1, 1    |    2, 1    |    3, 1    |
                    I    0, 0    I    1, 0    |    2, 0    |    -, -    |
                    I            I            |            |            |
                    I------------==============------------|------------|
                    I            |            I            |            |
                    I    0, 2    |    1, 2    I    2, 2    |    3, 2    |
                    I    0, 1    |    1, 1    I    2, 1    |    -, -    |
                    I            |            I            |            |
                    I------------|------------==============------------|
                    I            |            |            I            |
                    I    0, 3    |    1, 3    |    2, 3    I    3, 3    |
                    I    0, 2    |    1, 2    |    2, 2    I    -, -    |
                    I            |            |            I            |
                    I======================================I------------|
                    From the above it should be clear that:
                    
                    parameter x = grid x
                    parameter y = grid y + 1
                    grid nr = grid y + grid x * (dims - 1)
                    view nr = grid nr - (grid nr / dims) * ((grid nr / dims) +1) / 2
                    

                """

                # Set up QHull triangulation and interpolator:
                # If this fails, bail out and forget the rest...
                try:
                    triang = qhull.Delaunay(points)
                    interp = scipy.interpolate.LinearNDInterpolator(triang, values)
                except RuntimeError:
                    return #ignore error and return
                
                grid = ImageGrid(
                    figure, 111, 
                    nrows_ncols = (dims-1, dims-1),
                    cbar_location = "right",
                    cbar_mode="single",
                    #add_all=False,
                    aspect=False,
                    axes_pad=0.1,
                    direction="column"
                )

                # Helper to get the axes from the image grid:               
                def get_gridnr(gridx, gridy):
                    #Plot number:
                    return gridy + gridx * (dims-1)
                
                rect = (0.1, 0.1, 0.8, 0.8)
                horiz = [Size.Fixed(.1)] + [Size.Scaled(1.), Size.Fixed(.1)]*max(dims-1, 1) + [Size.Fixed(0.15)]
                vert = [Size.Fixed(.1)] + [Size.Scaled(1.), Size.Fixed(.1)]*max(dims-1, 1)
                
                # divide the axes rectangle into grid whose size is specified by horiz * vert
                divider = Divider(figure, rect, horiz, vert) #, aspect=False)
                
                def get_locator(gridx, gridy):
                    nx = 1 + gridx * 2
                    ny = 1 + (dims-gridy-2) * 2
                    return divider.new_locator(nx=nx, ny=ny)
                
                # Keep a reference to the images created,
                # se we can add a scale bar for all images (and they have the same range)
                ims = []
                tvmin, tvmax = None, None
                
                for parx, pary in itertools.product(range(dims), range(dims)):
                
                    #Calculate these, so wo don't need to worry about them:
                    gridx = parx
                    gridy = pary - 1
                    
                    if pary > 0 and parx < (dims-1):
                        gridnr = get_gridnr(gridx, gridy)                    
                        ax = grid[gridnr]
                    else:
                        ax = None
                
                    if pary <= parx: #only show 'bottom triangle' plots, top is just a copy, but transposed
                        if ax: ax.set_visible(False)
                        continue
                    
                    #Calculate the view:
                    coords = []
                    mn, mx = min(parx, pary), max(parx, pary)
                    for x,y in itertools.product(
                            np.linspace(mins[mn],maxs[mn],density),
                            np.linspace(mins[mx],maxs[mx],density)):
                        coord = centroid[:mn]
                        coord += [x,]
                        coord += centroid[mn+1:mx]
                        coord += [y,]
                        coord += centroid[mx+1:]
                        coords.append(coord)      
                    view = interp(coords).reshape(density, density).transpose()
                    
                    if ax!=None:
                        #Setup axes:
                        ax.set_axes_locator(get_locator(gridx, gridy))
                        ax.set_visible(True)
                        extent = (mins[parx],maxs[parx],mins[pary],maxs[pary])

                        #Plot the residual parameter space cross-section:
                        aspect = 'auto' #abs((extent[1]-extent[0]) / (extent[3] - extent[2]))
                        im = ax.imshow(view, origin='lower', aspect=aspect, extent=extent, alpha=0.75)
                        #ax.set_aspect(aspect)
                        im.set_cmap('gray_r')
                        vmin, vmax = im.get_clim()
                        if tvmin == None: tvmin = vmin
                        if tvmax == None: tvmax = vmax                        
                        tvmin, tvmax = min(tvmin, vmin), max(tvmax, vmax)
                        
                        ims.append(im)
                        
                        #Add a contour & labels:
                        ct = ax.contour(view, colors='k', aspect=aspect, extent=extent, origin='lower')
                        ax.clabel(ct, colors='k', fontsize=10, format="%1.2f")
                        
                        #Add a red cross where the 'best' solution is:
                        ax.plot((centroid[parx],), (centroid[pary],), 'r+')
                        
                        #Rotate x labels
                        for lbl in ax.get_xticklabels():
                            lbl.set_rotation(90)
                            
                        #Reduce number of ticks:
                        ax.locator_params(axis='both', nbins=5)
                        
                        #Set limits:
                        ax.set_xlim(extent[0:2])
                        ax.set_ylim(extent[2:4])

                        #Add labels to the axes so the user knows which is which:
                        # TODO add some flags/color/... indicating which phase & component each parameter belongs to...
                        if parx==0:
                            ax.set_ylabel(str("#%d " % (pary+1)) + get_plot_safe(self.model.ref_props[pary].title)) 
                        if pary==(dims-1):
                            ax.set_xlabel(str("#%d " % (parx+1)) + get_plot_safe(self.model.ref_props[parx].title))
                            
                #Set the data limits:
                for im in ims:
                    im.set_clim(tvmin, tvmax)

                #Make it look PRO:
                if im !=None:
                    cbar_ax = grid.cbar_axes[0]
                    nx = 1 + (dims-1)*2
                    ny1 = (dims-1) * 2
                    cbar_ax.set_axes_locator(divider.new_locator(nx=nx, ny=1, ny1=ny1))
                    cb = cbar_ax.colorbar(im)
        except:            
            print "Unhandled exception while generating parameter space images:"
            print format_exc()
    pass #end of class

class RefinementController(DialogController):

    def update_method_options_store(self):
        #1 get the method:
        refine_method = self.model.get_refine_method()
    
        #2 get the options:
        options = refine_method.options
        
        tv = self.view['tv_method_options']
        
        #3 make a liststore
        store = gtk.ListStore(str, object, str, object, object, object)
        for name, arg, typ, default, limits in options:
            store.append([name, default, arg, typ, default, limits])
            
        tv.set_model(store)
        
        return tv
        
    def setup_method_options_treeview(self):
        tv = self.update_method_options_store()
    
        tv.append_column(new_text_column("Name", text_col=0))
        
        def get_value(column, cell, model, itr, *args):
            name, value, arg, typ, default, limits = tv.get_model().get(itr, 0, 1, 2, 3, 4, 5)
            if typ in (int, float, str):
                value = str(value)
                cell.set_property("sensitive", True)
                cell.set_property("editable", True)
            else:
                value = ""
                cell.set_property("sensitive", False)
                cell.set_property("editable", False)                
            cell.set_property("markup",  value)                    
            return
        def on_value_edited(rend, path, new_text, col):
            store = tv.get_model()
            itr = store.get_iter(path)
            name, value, arg, typ, default, limits = store.get(itr, 0, 1, 2, 3, 4, 5)
            if typ in (int, float, str):
                try:
                    value = typ(new_text)
                    if typ in (int, float,):
                        min_value, max_value = limits
                        if min_value!=None: value = max(min_value, value)
                        if max_value!=None: value = min(max_value, value)
                        store.set_value(itr, col, value)                        
                    elif limits!=None:
                        if value in limits:
                            store.set_value(itr, col, value)
                        else:
                            raise ValueError
                except ValueError:
                    pass
            else:
                pass
            return True
                  
        tv.append_column(new_text_column(
            "Value", text_col=1, 
            data_func=get_value,
            edited_callback=(on_value_edited, (1,)), 
        ))
        
        def get_check_value(column, cell, model, itr, *args):
            name, value, arg, typ, default, limits = tv.get_model().get(itr, 0, 1, 2, 3, 4, 5)
            if typ in (bool,):
                value = bool(value)
                cell.set_property("active",  value)
                cell.set_property("visible", True)
                cell.set_property("sensitive", True)
                cell.set_property("activatable", True)
            else:
                cell.set_property("visible", False)
                cell.set_property("sensitive", False)
                cell.set_property("activatable", False)
            return
        def on_value_toggled(cell, path, col):
            store = tv.get_model()
            itr = store.get_iter(path)
            name, value, arg, typ, default, limits = store.get(itr, 0, 1, 2, 3, 4, 5)
            if typ in (bool,):
                store.set_value(itr, col, cell.get_active())
            else:
                pass
            return True
        
        #An optional checkbox:
        tv.append_column(new_toggle_column(
                "",
                data_func=get_check_value,
                toggled_callback=(on_value_toggled, (1,)),
                resizable=False,
                expand=False
        ))    

    def register_adapters(self):
        if self.model is not None:  
            tv_model = self.model.refinables
            tv = self.view['tv_param_selection']
            tv.set_show_expanders(True)
            tv.set_model(tv_model)
                          
            #Labels are parsed for mathtext markup into pb's:                   
            def get_pb(column, cell, model, itr, user_data=None):
                ref_prop = model.get_user_data(itr)
                if not hasattr(ref_prop, "pb") or not ref_prop.pb:
                    ref_prop.pb = create_pb_from_mathtext(
                        ref_prop.title,
                        align='left', 
                        weight='medium'
                    )
                cell.set_property("pixbuf", ref_prop.pb)
                return       
            tv.append_column(new_pb_column('Name/Prop', xalign=0.0, data_func=get_pb))

            #Editable floats:
            def get_value(column, cell, model, itr, *args):
                value = model.get_value(itr, column.get_col_attr('markup'))
                try: value = "%.5f" % value
                except TypeError: value = ""
                cell.set_property("markup",  value)                    
                return
            def on_float_edited(rend, path, new_text, col):
                itr = tv_model.get_iter(path)
                tv_model.set_value(itr, col, float(new_text))
                return True
                
            def_float_args = {
                "sensitive_col": tv_model.c_refinable,
                "editable_col": tv_model.c_refinable,
                "visible_col": tv_model.c_refinable,
                "data_func": get_value
            }
                
            tv.append_column(new_text_column("Value", markup_col=tv_model.c_value,
                    edited_callback=(on_float_edited, (tv_model.c_value,)), 
                    **def_float_args))
            tv.append_column(new_text_column("Min", markup_col=tv_model.c_value_min,
                    edited_callback=(on_float_edited, (tv_model.c_value_min,)), 
                    **def_float_args))
            tv.append_column(new_text_column("Max", markup_col=tv_model.c_value_max,
                    edited_callback=(on_float_edited, (tv_model.c_value_max,)), 
                    **def_float_args))
            
            #The 'refine' checkbox:
            tv.append_column(new_toggle_column("Refine",
                    toggled_callback=(self.refine_toggled, (tv_model,)),
                    resizable=False,
                    expand=False,
                    active_col=tv_model.c_refine,
                    sensitive_col=tv_model.c_refinable,
                    activatable_col=tv_model.c_refinable,
                    visible_col=tv_model.c_refinable))
                       
            #Refine method combobox:
            ctrl_setup_combo_with_list(self, 
                self.view["cmb_data_refine_method"],
                "refine_method", "_refine_methods")
            
        return

    def register_view(self, view):
        self.setup_method_options_treeview()        

    # ------------------------------------------------------------
    #      Notifications of observable properties
    # ------------------------------------------------------------
    @Observer.observe("refine_method", assign=True)
    def on_prop_changed(self, model, prop_name, info):
        self.update_method_options_store()
            
    # ------------------------------------------------------------
    #      GTK Signal handlers
    # ------------------------------------------------------------
    def on_cancel(self):
        if not self.model.refiner.refine_lock:
            self.view.hide()
        else:
            return True #do nothing
    
    def refine_toggled(self, cell, path, model):
        if model is not None:
            itr = model.get_iter(path)
            model.set_value(itr, model.c_refine, not cell.get_active())
        return True
        
    def on_btn_randomize_clicked(self, event):
        self.model.randomize()
        
    def on_auto_restrict_clicked(self, event):
        self.model.auto_restrict()
        
    @DialogController.status_message("Refining mixture...", "refine_mixture")
    def on_refine_clicked(self, event):
        #Setup mixture based on chosen refinement options:
        self.model.refine_options = {}
        option_store = self.view['tv_method_options'].get_model()
        for name, value, arg, typ, default, limits in option_store:
            self.model.refine_options[arg] = value
           
        #Setup context and results controller:
        self.model.refiner.setup_context() 
        self.results_view = RefinementResultView(parent=self.view)
        self.results_controller = RefinementResultsController(
            model=self.model.refiner.context,
            view=self.results_view,
            parent=self
        )
            
        #Run the refinement thread:
        self.view.show_refinement_info(
            self.model.refiner.refine, #REFINE METHOD
            self.update_residual,      #GUI UPDATER
            self.on_complete           #ON COMPLETE CALLBACK
        )
        
    def on_complete(self, *args, **kwargs):
        self.results_controller.generate_images()
        self.results_view.present()
        
    def update_residual(self):
        self.view.update_refinement_info(self.model.refiner.context.last_residual)
        
    pass #end of class
        
class EditMixtureController(BaseController):

    chicken_egg = False
    ref_view = None

    def register_adapters(self):
        if self.model is not None:
            for name in self.model.get_properties():
                if name == "name":
                    self.adapt(name, "mixture_name")
                elif not name in self.model.__have_no_widget__+  ["refinables", "refine_method"]:
                    self.adapt(name)
            self.create_ui()
            return
            
    def create_ui(self):
        self.view.reset_view()
        for index, phase in enumerate(self.model.phases):
            self.add_phase_view(index)
        for index, specimen in enumerate(self.model.specimens):
            self.add_specimen_view(index)
               
    def add_phase_view(self, index):
        def on_label_changed(editable):
            self.model.phases[index] = editable.get_text()
        
        def on_fraction_changed(editable):
            try: self.model.fractions[index] = float(editable.get_text())
            except ValueError: pass #ignore ValueErrors
        
        def on_phase_delete(widget):
            self.model._del_phase_by_index(index)
            widget.disconnect(widget.get_data("deleventid"))
        
        self.view.add_phase(self.model.parent.phases, 
            on_phase_delete, on_label_changed, on_fraction_changed, 
            self.on_combo_changed, label=self.model.phases[index], 
            fraction=self.model.fractions[index], phases=self.model.phase_matrix)
    
    def add_specimen_view(self, index):
        def on_scale_changed(editable):
            try: self.model.scales[index] = float(editable.get_text())
            except ValueError: pass #ignore ValueErrors

        def on_bgs_changed(editable):
            try: self.model.bgshifts[index] = float(editable.get_text())
            except ValueError: pass #ignore ValueErrors

        def on_specimen_changed(combobox):
            itr = combobox.get_active_iter()
            specimen = self.model.parent.specimens.get_user_data(itr) if itr!=None else None
            self.model.specimens[index] = specimen
        
        def on_specimen_delete(widget):
            self.model._del_specimen_by_index(index)
            widget.disconnect(widget.get_data("deleventid"))
        
        self.view.add_specimen(self.model.parent.phases, 
            self.model.parent.specimens, on_specimen_delete, on_scale_changed,
            on_bgs_changed, on_specimen_changed, self.on_combo_changed, 
            scale=self.model.scales[index], bgs=self.model.bgshifts[index],
            specimen=self.model.specimens[index], phases=self.model.phase_matrix)
    
    # ------------------------------------------------------------
    #      Notifications of observable properties
    # ------------------------------------------------------------   
    @Controller.observe("has_changed", signal=True)
    def notif_has_changed(self, model, prop_name, info):
        if not self.chicken_egg:
            self.view.update_all(self.model.fractions, self.model.scales, self.model.bgshifts)
        
    @Controller.observe("needs_reset", signal=True)
    def notif_needs_reset(self, model, prop_name, info):
        self.create_ui()

    # ------------------------------------------------------------
    #      GTK Signal handlers
    # ------------------------------------------------------------
    def on_combo_changed(self, combobox, row, col):
        itr = combobox.get_active_iter()
        phase = self.model.parent.phases.get_user_data(itr) if itr!=None else None
        self.model.phase_matrix[row, col] = phase
    
    def on_add_phase(self, widget, *args):
        self.chicken_egg = True
        index = self.model.add_phase("New Phase", 1.0)
        if index != -1:
            self.add_phase_view(index)
        self.chicken_egg = False
        
    def on_add_specimen(self, widget, *args):
        self.chicken_egg = True
        index = self.model.add_specimen(None, 1.0, 0.0)
        self.add_specimen_view(index)
        self.chicken_egg = False
    
    def on_add_both(self, widget, *args):
        self.chicken_egg = True
        self.on_add_specimen(widget, *args)
        self.on_add_phase(widget, *args)
        self.chicken_egg = False
    
    def on_optimize_clicked(self, widget, *args):
        self.model.optimizer.optimize()
        return

    def on_refine_clicked(self, widget, *args):
        self.model.update_refinement_treestore()
        if self.ref_view!=None: 
            self.ref_view.hide()
        else:
            self.ref_view = RefinementView(parent=self.parent.view)
            self.ref_ctrl = RefinementController(self.model, self.ref_view, parent=self)
        self.ref_view.present()        
    
    def on_composition_clicked(self, widget, *args):
        comp  = "The composition of the specimens in this mixture:\n\n\n"
        comp += "<span font-family=\"monospace\">"
        #get the composition matrix (first columns contains strings with elements, others are specimen compositions)
        import re
        for row in self.model.get_composition_matrix():
            comp += "%s %s\n" % (re.sub(r'(\d+)', r'<sub>\1</sub>', row[0]), " ".join(row[1:]))
        comp += "</span>"
        self.run_information_dialog(comp, parent=self.view.get_toplevel())
    
    pass #end of class

class MixturesController(ObjectListStoreController):

    model_property_name = "mixtures"
    columns = [ ("Mixture name", "c_name") ]
    delete_msg = "Deleting a mixture is irreverisble!\nAre You sure you want to continue?"

    def get_new_edit_view(self, obj):
        if isinstance(obj, Mixture):
            return EditMixtureView(parent=self.view)
        else:
            return ObjectListStoreController.get_new_edit_view(self, obj)
        
    def get_new_edit_controller(self, obj, view, parent=None):
        if isinstance(obj, Mixture):
            return EditMixtureController(obj, view, parent=parent)
        else:
            return ObjectListStoreController.get_new_edit_controller(self, obj, view, parent=parent)
    
    # ------------------------------------------------------------
    #      GTK Signal handlers
    # ------------------------------------------------------------        
    def on_load_object_clicked(self, event):
        pass #cannot load mixtures
    def on_save_object_clicked(self, event):
        pass #cannot save mixtures
        
    def create_new_object_proxy(self):
        return Mixture(parent=self.model)
        
    pass #end of class
